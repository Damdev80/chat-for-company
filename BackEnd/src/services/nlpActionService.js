// src/services/nlpActionService.js - Servicio para procesar acciones en lenguaje natural
import { ModelsObjective } from '../models/objective.js'
import { ModelsTask } from '../models/task.js'
import { Event } from '../models/event.js'
import { Idea } from '../models/idea.js'
import * as chrono from 'chrono-node'

/**
 * Servicio para interpretar lenguaje natural y ejecutar acciones en la BD
 * Permite a ALEXANDRA crear tareas, objetivos y eventos basados en comandos del usuario
 */
class NLPActionService {
  
  /**
   * Detecta si el mensaje contiene una solicitud de acci√≥n
   */
  detectAction(message) {
    const lowerMessage = message.toLowerCase()
    
    console.log('üîç NLP: Analizando mensaje para detectar acci√≥n...')
    console.log('   Mensaje:', message)
    
    // Patrones MEJORADOS - Mucho m√°s flexibles
    const patterns = {
      // Detectar TAREAS - Ampliado
      createTask: /(?:crea|crear|agrega|agregar|a√±ade|a√±adir|nueva?|nuevo|haz|hacer|pon|poner|guarda|guardar|registra|registrar)\s+(?:una\s+|la\s+)?tarea|tarea\s+(?:nueva|urgente|importante|pendiente)|(?:tengo|hay)\s+(?:una\s+)?tarea|(?:anota|apunta)\s+(?:esta\s+)?tarea/i,
      
      // Detectar IDEAS - NUEVO
      createIdea: /(?:crea|crear|agrega|agregar|a√±ade|a√±adir|nueva?|nuevo|pon|poner|publica|publicar|comparte|compartir|sube|subir)\s+(?:una\s+|esta\s+)?idea|idea\s+(?:nueva|para|sobre)|(?:tengo|se me ocurre|se me ocurri√≥)\s+(?:una\s+)?idea|(?:al\s+)?muro\s+de\s+ideas/i,
      
      // Detectar OBJETIVOS - Ampliado y m√°s flexible
      createObjective: /(?:crea|crear|agrega|agregar|a√±ade|a√±adir|nuevo|establece|establecer|define|definir|fija|fijar)(?:\s+un\s+|\s+una\s+|\s+)(?:objetivo|meta|logro)(?:\s+que\s+sea|\s+de|\s+para|\s+sobre)?|objetivo\s+(?:nuevo|de|para)|(?:meta|logro)\s+(?:nueva?|de|para)/i,
      
      // Detectar EVENTOS - Ampliado
      createEvent: /(?:crea|crear|agrega|agregar|a√±ade|a√±adir|agenda|agendar|programa|programar|haz|hacer|necesito|quiero|pon|poner)\s+(?:un\s+|una\s+)?(?:evento|reuni√≥n|reunion|meeting|cita|junta)|(?:reuni√≥n|reunion|meeting|cita|junta)\s+(?:para|el|ma√±ana|hoy|pasado|urgente|importante)|(?:al\s+)?calendario/i,
      
      // Detectar RECORDATORIOS
      scheduleReminder: /(?:recuerda|recor dar|recu√©rdame|avisa|avisar|av√≠same|notifica|notificar)\s+(?:que|de|sobre|cuando)/i,
      
      // Detectar PLAZOS
      setDeadline: /(?:fecha\s+l√≠mite|deadline|plazo|vence|vencimiento|fecha\s+de\s+entrega)\s+(?:para|el|en|de)/i,
      
      // üÜï CONSULTAS DE INFORMACI√ìN
      queryTasks: /(?:c√≥mo|como)\s+(?:van|est√°|est√°n|anda|andan)\s+(?:las?\s+)?tareas?|(?:cu√°les|cuales|qu√©|que)\s+tareas?|(?:estado|progreso)\s+(?:de\s+)?(?:las?\s+)?tareas?|(?:tareas?\s+de\s+)(?:\w+)/i,
      
      queryGroupInfo: /(?:cu√°ntos|cuantos|qu√©|que)\s+(?:miembros|usuarios|personas)|(?:qui√©nes|quienes)\s+(?:est√°n|son)|(?:integrantes|participantes)\s+(?:del\s+)?grupo|(?:informaci√≥n|info)\s+(?:del\s+)?grupo/i,
      
      // üÜï GESTI√ìN DE TAREAS
      takeTask: /(?:tomo|tomar|tomar√©|asumo|asumir|me\s+asigno|asignarme)\s+(?:la\s+)?tarea|(?:yo\s+(?:lo\s+)?hago|me\s+encargo)/i,
      
      listFreeTasks: /(?:tareas?\s+)?(?:libres|disponibles|sin\s+asignar)|(?:qu√©|cu√°les)\s+tareas?\s+(?:puedo\s+tomar|est√°n\s+libres)/i
    }
    
    for (const [action, pattern] of Object.entries(patterns)) {
      if (pattern.test(lowerMessage)) {
        console.log('‚úÖ NLP: Acci√≥n detectada:', action)
        console.log('   Patr√≥n:', pattern)
        return action
      }
    }
    
    console.log('‚ùå NLP: No se detect√≥ ninguna acci√≥n')
    return null
  }

  /**
   * Extrae informaci√≥n de una solicitud de tarea
   */
  extractTaskInfo(message, userId, groupId) {
    const lowerMessage = message.toLowerCase()
    
    console.log('üìù NLP: Extrayendo informaci√≥n de tarea...')
    console.log('   Mensaje:', message)
    
    // Extraer t√≠tulo - MEJORADO con m√∫ltiples patrones
    let title = 'Nueva tarea'
    
    const titlePatterns = [
      // "tarea: [t√≠tulo]" o "tarea de [t√≠tulo]"
      /tarea[\s:]+(?:de\s+|para\s+|sobre\s+)?["']?([^"'\n]+?)(?:["']|\s+(?:urgente|importante|prioridad|descripci√≥n)|$)/i,
      // "crear/agregar tarea [t√≠tulo]"
      /(?:crea|crear|agrega|agregar|a√±ade|nueva|pon)\s+(?:una\s+)?tarea\s+["']?([^"'\n]+?)(?:["']|$)/i,
      // "tarea [t√≠tulo]" (simplificado)
      /tarea\s+([^.\n]+?)(?:\.|$)/i,
      // Cualquier texto despu√©s de mencionar tarea
      /tarea.*?:\s*(.+?)(?:\.|$)/i
    ]
    
    for (const pattern of titlePatterns) {
      const match = message.match(pattern)
      if (match && match[1] && match[1].trim().length > 0) {
        title = match[1].trim()
        // Limpiar palabras innecesarias del t√≠tulo
        title = title.replace(/(?:urgente|importante|prioridad|alta|media|baja|cr√≠tica)/gi, '').trim()
        if (title.length > 3) break
      }
    }
    
    // Si no encontramos t√≠tulo espec√≠fico, usar el mensaje completo (limpio)
    if (title === 'Nueva tarea') {
      title = message
        .replace(/(?:crea|crear|agrega|agregar|a√±ade|a√±adir|nueva|nuevo|haz|hacer|pon|poner)\s+(?:una\s+)?tarea\s*/gi, '')
        .replace(/(?:urgente|importante|prioridad alta)/gi, '')
        .trim()
      if (title.length > 100) title = title.substring(0, 100) + '...'
      if (title.length < 3) title = 'Nueva tarea'
    }
    
    console.log('   T√≠tulo extra√≠do:', title)
    
    // Detectar prioridad - MEJORADO
    let priority = 'medium'
    if (/urgente|cr√≠tica?|cr√≠tico|alta|high|prioridad\s+alta|muy\s+importante/i.test(lowerMessage)) {
      priority = 'critical'
    } else if (/importante|media|medium|prioridad\s+media|normal/i.test(lowerMessage)) {
      priority = 'high'
    } else if (/baja|low|prioridad\s+baja|no\s+urgente/i.test(lowerMessage)) {
      priority = 'low'
    }
    
    console.log('   Prioridad:', priority)
    
    // Extraer descripci√≥n (texto despu√©s de descripci√≥n/detalles)
    const descMatch = message.match(/(?:descripci√≥n|detalles?|sobre|acerca de):\s*([^\.]+)/i)
    const description = descMatch ? descMatch[1].trim() : ''
    
    // üÜï Detectar asignaci√≥n de usuario
    let assigned_to = null
    const assignPatterns = [
      /(?:asigna|asignar|para|asignado?\s+a)\s+(?:@)?(\w+)/i,
      /(?:que\s+lo\s+haga|encargado)\s+(?:@)?(\w+)/i,
      /(?:responsable)\s+(?:@)?(\w+)/i
    ]
    
    for (const pattern of assignPatterns) {
      const match = message.match(pattern)
      if (match && match[1]) {
        assigned_to = match[1].toLowerCase()
        console.log('   üë§ Asignado a:', assigned_to)
        break
      }
    }
    
    // Detectar si es para "todos"
    if (/(?:para\s+)?todos|todo\s+el\s+(?:equipo|grupo)|equipo\s+completo/i.test(message)) {
      assigned_to = 'all'
      console.log('   üë• Asignado a: TODOS')
    }
    
    // Detectar fecha usando chrono-node
    const parsedDates = chrono.es.parse(message)
    const deadline = parsedDates.length > 0 ? parsedDates[0].start.date() : null
    
    console.log('   Deadline:', deadline ? deadline.toISOString().split('T')[0] : 'ninguna')
    
    return {
      title,
      description,
      priority,
      deadline: deadline ? deadline.toISOString().split('T')[0] : null,
      group_id: groupId,
      created_by: userId,
      assigned_to: assigned_to, // Ahora detecta usuario o 'all'
      status: 'pending'
    }
  }

  /**
   * Extrae informaci√≥n de una solicitud de objetivo
   */
  extractObjectiveInfo(message, userId, groupId) {
    console.log('\nüìã EXTRACT OBJECTIVE INFO:')
    console.log('   üìù Mensaje:', message)
    console.log('   üë§ User ID:', userId)
    console.log('   üè¢ Group ID RECIBIDO:', groupId)
    console.log('   üîç Tipo de groupId:', typeof groupId)
    console.log('   ‚ùì Es null?:', groupId === null)
    console.log('   ‚ùì Es undefined?:', groupId === undefined)
    
    const lowerMessage = message.toLowerCase()
    
    // Extraer t√≠tulo - MEJORADO con m√∫ltiples patrones
    let title = 'Nuevo objetivo'
    
    const titlePatterns = [
      // "crea un objetivo que sea [t√≠tulo] con descripci√≥n..."
      /objetivo\s+(?:que\s+sea\s+)?(?:de\s+|para\s+|sobre\s+)?["']?([^"'\n]+?)(?:["']|\s+(?:con\s+)?(?:descripci√≥n|descripcion|detalles|para|el|fecha|deadline)|$)/i,
      // "objetivo [t√≠tulo] descripci√≥n..."
      /objetivo\s+(.+?)(?:\s+(?:con\s+)?(?:descripci√≥n|descripcion|para|el|ma√±ana|hoy|deadline)|$)/i,
      // Fallback
      /(?:meta|logro)\s+(?:de\s+|para\s+)?(.+?)(?:\s+(?:descripci√≥n|descripcion|para|el|deadline)|$)/i
    ]
    
    for (const pattern of titlePatterns) {
      const match = message.match(pattern)
      if (match && match[1] && match[1].trim().length > 0) {
        title = match[1].trim()
        // Limpiar frases innecesarias
        title = title
          .replace(/^(?:que\s+sea\s+|de\s+|para\s+|sobre\s+)/i, '')
          .replace(/(?:\s+con\s+)?(?:descripci√≥n|descripcion|detalles|fecha|deadline).*$/i, '')
          .trim()
        if (title.length > 3) break
      }
    }
    
    console.log('   üìå T√≠tulo extra√≠do:', title)
    
    // Extraer descripci√≥n - MEJORADO con m√°s patrones
    let description = ''
    const descPatterns = [
      /(?:con\s+)?(?:descripci√≥n|descripcion):\s*([^,\.\n]+)/i,
      /(?:con\s+)?(?:descripci√≥n|descripcion)\s+(?:que\s+)?(.+?)(?:\s+(?:fecha|para|ma√±ana|hoy)|$)/i,
      /(?:detalles?|consiste\s+en|que\s+consiste\s+en):\s*([^,\.\n]+)/i,
      /(?:detalles?)\s+(.+?)(?:\s+(?:fecha|para|ma√±ana|hoy)|$)/i
    ]
    
    for (const pattern of descPatterns) {
      const match = message.match(pattern)
      if (match && match[1] && match[1].trim().length > 0) {
        description = match[1].trim()
        // Limpiar la descripci√≥n de fechas y palabras clave de fecha
        description = description
          .replace(/(?:fecha|para el|ma√±ana|hoy|deadline).*$/i, '')
          .trim()
        break
      }
    }
    
    console.log('   üìù Descripci√≥n extra√≠da:', description || '(ninguna)')
    
    // Detectar fecha l√≠mite usando chrono-node - MEJORADO
    let deadline = null
    
    // Primero buscar con patrones espec√≠ficos
    const datePatterns = [
      /(?:fecha\s+l√≠mite|fecha\s+limite|deadline|plazo|vence|para\s+el|hasta\s+el)[:\s]+(.+?)(?:\s*\.|$)/i,
    ]
    
    for (const pattern of datePatterns) {
      const match = message.match(pattern)
      if (match && match[1]) {
        console.log('   üîç Fecha encontrada con patr√≥n:', match[1])
        const parsedDates = chrono.es.parse(match[1])
        if (parsedDates.length > 0) {
          deadline = parsedDates[0].start.date()
          break
        }
      }
    }
    
    // Si no se encontr√≥ con los patrones espec√≠ficos, buscar en todo el mensaje
    if (!deadline) {
      const allParsedDates = chrono.es.parse(message)
      if (allParsedDates.length > 0) {
        deadline = allParsedDates[0].start.date()
      }
    }
    
    console.log('   üìÖ Fecha l√≠mite extra√≠da:', deadline ? deadline.toISOString().split('T')[0] : '(ninguna)')
    
    const objectiveInfo = {
      title,
      description,
      group_id: groupId,
      created_by: userId,
      deadline: deadline ? deadline.toISOString().split('T')[0] : null
    }
    
    console.log('   ‚úÖ Objective Info construido:')
    console.log('      title:', objectiveInfo.title)
    console.log('      description:', objectiveInfo.description || '(vac√≠a)')
    console.log('      group_id:', objectiveInfo.group_id)
    console.log('      created_by:', objectiveInfo.created_by)
    console.log('      deadline:', objectiveInfo.deadline || '(ninguna)')
    
    return objectiveInfo
  }

  /**
   * Extrae informaci√≥n de una solicitud de evento
   */
  extractEventInfo(message, userId, groupId) {
    const lowerMessage = message.toLowerCase()
    
    console.log('üìÖ NLP: Extrayendo informaci√≥n de evento...')
    console.log('   Mensaje:', message)
    
    // Extraer t√≠tulo del evento - MEJORADO para ser m√°s flexible
    let title = 'Nuevo evento'
    
    // Intentar diferentes patrones
    const titlePatterns = [
      // "hacer/crear una reuni√≥n [t√≠tulo]"
      /(?:evento|reuni√≥n|reunion|meeting|cita|junta)\s+(?:de|sobre|para|con|llamada)\s+["']?([^"'\n]+?)(?:["']|\s+(?:ma√±ana|hoy|pasado|el|a las|para|descripci√≥n)|$)/i,
      // "reuni√≥n [t√≠tulo] ma√±ana"
      /(?:evento|reuni√≥n|reunion|meeting|cita|junta)\s+["']?([^"'\n]+?)(?:["']|\s+(?:ma√±ana|hoy|pasado|el|a las))/i,
      // Fallback: cualquier texto despu√©s de "reuni√≥n"
      /(?:evento|reuni√≥n|reunion|meeting|cita|junta)\s+(.+?)(?:\s+(?:ma√±ana|hoy|pasado|el)|$)/i
    ]
    
    for (const pattern of titlePatterns) {
      const match = message.match(pattern)
      if (match && match[1]) {
        title = match[1].trim()
        break
      }
    }
    
    // Si a√∫n no encontramos t√≠tulo, usar descripci√≥n general
    if (title === 'Nuevo evento') {
      // Buscar verbos de acci√≥n y extraer lo que sigue
      const actionMatch = message.match(/(?:hacer|haz|crear|crea|agenda|agendar)\s+(?:una\s+)?(?:reuni√≥n|reunion|meeting)\s+(.+?)(?:\s+(?:ma√±ana|hoy|pasado|el)|$)/i)
      if (actionMatch && actionMatch[1]) {
        title = actionMatch[1].trim()
      }
    }
    
    console.log('   T√≠tulo extra√≠do:', title)
    
    // Detectar tipo de evento
    let event_type = 'reminder'
    if (/reuni√≥n|meeting|junta/i.test(lowerMessage)) event_type = 'meeting'
    else if (/deadline|fecha\s+l√≠mite|plazo/i.test(lowerMessage)) event_type = 'deadline'
    else if (/hito|milestone/i.test(lowerMessage)) event_type = 'milestone'
    else if (/celebraci√≥n|celebrar/i.test(lowerMessage)) event_type = 'celebration'
    
    console.log('   Tipo de evento:', event_type)
    
    // Detectar prioridad
    let priority = 'medium'
    if (/urgente|cr√≠tica|alta/i.test(lowerMessage)) priority = 'high'
    else if (/importante/i.test(lowerMessage)) priority = 'medium'
    else if (/baja/i.test(lowerMessage)) priority = 'low'
    
    // Extraer descripci√≥n
    const descMatch = message.match(/(?:descripci√≥n|detalles?|sobre|acerca de):\s*([^\.]+)/i)
    const description = descMatch ? descMatch[1].trim() : ''
    
    console.log('   Descripci√≥n:', description || '(ninguna)')
    
    // Parsear fecha y hora usando chrono-node
    console.log('   Parseando fecha con chrono...')
    const parsedDates = chrono.es.parse(message, new Date(), { forwardDate: true })
    
    console.log('   Fechas detectadas:', parsedDates.length)
    
    let event_date = null
    let event_time = null
    
    if (parsedDates.length > 0) {
      const parsedDate = parsedDates[0].start.date()
      event_date = parsedDate.toISOString().split('T')[0]
      
      console.log('   Fecha parseada:', event_date)
      
      // Si tiene hora espec√≠fica
      if (parsedDates[0].start.get('hour') !== null) {
        const hours = String(parsedDate.getHours()).padStart(2, '0')
        const minutes = String(parsedDate.getMinutes()).padStart(2, '0')
        event_time = `${hours}:${minutes}`
        console.log('   Hora parseada:', event_time)
      } else {
        console.log('   Sin hora espec√≠fica detectada')
      }
    } else {
      console.log('   ‚ö†Ô∏è No se pudo parsear ninguna fecha')
    }
    
    const eventInfo = {
      title,
      description,
      event_date,
      event_time,
      event_type,
      priority,
      group_id: groupId,
      user_id: userId,
      reminder_enabled: true,
      reminder_minutes: 30
    }
    
    console.log('   Info final del evento:', JSON.stringify(eventInfo, null, 2))
    
    return eventInfo
  }

  /**
   * Extrae informaci√≥n de una solicitud de idea
   */
  extractIdeaInfo(message, userId, groupId) {
    const lowerMessage = message.toLowerCase()
    
    console.log('üí° NLP: Extrayendo informaci√≥n de idea...')
    console.log('   Mensaje:', message)
    
    // Extraer t√≠tulo - MEJORADO
    let title = 'Nueva idea'
    
    const titlePatterns = [
      // "idea: [t√≠tulo]" o "idea sobre [t√≠tulo]"
      /idea[\s:]+(?:sobre\s+|para\s+|de\s+)?["']?([^"'\n]+?)(?:["']|\s+(?:descripci√≥n|categor√≠a)|$)/i,
      // "crear/agregar idea [t√≠tulo]"
      /(?:crea|crear|agrega|agregar|publica|nueva)\s+(?:una\s+)?idea\s+["']?([^"'\n]+?)(?:["']|$)/i,
      // "tengo una idea [t√≠tulo]"
      /(?:tengo|se me ocurre|se me ocurri√≥)\s+(?:una\s+)?idea\s+["']?([^"'\n]+?)(?:["']|$)/i,
      // Simplificado: "idea [t√≠tulo]"
      /idea\s+([^.\n]+?)(?:\.|$)/i
    ]
    
    for (const pattern of titlePatterns) {
      const match = message.match(pattern)
      if (match && match[1] && match[1].trim().length > 0) {
        title = match[1].trim()
        if (title.length > 5) break
      }
    }
    
    // Si no encontramos t√≠tulo, usar el mensaje completo limpio
    if (title === 'Nueva idea') {
      title = message
        .replace(/(?:crea|crear|agrega|agregar|publica|nueva?|pon|poner)\s+(?:una\s+)?idea\s*/gi, '')
        .replace(/(?:muro\s+de\s+ideas|al\s+muro)/gi, '')
        .trim()
      if (title.length > 100) title = title.substring(0, 100) + '...'
      if (title.length < 3) title = 'Nueva idea'
    }
    
    console.log('   T√≠tulo extra√≠do:', title)
    
    // Extraer descripci√≥n
    const descMatch = message.match(/(?:descripci√≥n|detalles?|sobre|acerca de|consiste en):\s*([^\.]+)/i)
    const description = descMatch ? descMatch[1].trim() : ''
    
    console.log('   Descripci√≥n:', description || '(ninguna)')
    
    // Detectar categor√≠a
    let category = 'general'
    if (/(?:nueva\s+)?(?:funci√≥n|feature|funcionalidad)/i.test(lowerMessage)) category = 'feature'
    else if (/mejora|improvement|optimizaci√≥n/i.test(lowerMessage)) category = 'improvement'
    else if (/bug|error|problema|fallo/i.test(lowerMessage)) category = 'bug'
    
    console.log('   Categor√≠a:', category)
    
    // Detectar prioridad
    let priority = 'medium'
    if (/urgente|cr√≠tica?|alta|high|muy\s+importante/i.test(lowerMessage)) priority = 'high'
    else if (/baja|low|no\s+urgente/i.test(lowerMessage)) priority = 'low'
    
    console.log('   Prioridad:', priority)
    
    return {
      group_id: groupId,
      user_id: userId,
      title,
      description,
      category,
      priority
    }
  }

  /**
   * Ejecuta la acci√≥n detectada
   */
  async executeAction(actionType, message, userId, groupId, objectiveId = null) {
    try {
      console.log('\nüéØ NLP Action Service - Executing:', actionType)
      console.log('   üë§ User ID:', userId)
      console.log('   üè¢ Group ID RECIBIDO:', groupId)
      console.log('   üìù Mensaje:', message)
      console.log('   üéØ Objective ID:', objectiveId || 'ninguno')
      
      switch (actionType) {
        case 'createTask': {
          const taskInfo = this.extractTaskInfo(message, userId, groupId)
          
          // Si NO hay un objective_id especificado, buscar o crear "Tareas Generales"
          if (!objectiveId && !taskInfo.objective_id) {
            console.log('   No hay objetivo especificado, buscando/creando "Tareas Generales"...')
            
            // Buscar si existe el objetivo "Tareas Generales" en el grupo
            console.log('   üîç Buscando objetivos en grupo:', groupId)
            const objectives = await ModelsObjective.getByGroupId(groupId)
            console.log('   üìã Objetivos encontrados:', objectives.length)
            objectives.forEach(obj => console.log(`      - ${obj.title} (ID: ${obj.id})`))
            
            let generalObjective = objectives.find(obj => 
              obj.title.toLowerCase().includes('tareas generales') || 
              obj.title.toLowerCase().includes('general')
            )
            
            // Si no existe, crearlo
            if (!generalObjective) {
              console.log('   ‚ö†Ô∏è No existe "Tareas Generales", creando...')
              console.log('   üì¶ Datos para crear objetivo:', {
                title: 'Tareas Generales',
                group_id: groupId,
                created_by: userId
              })
              generalObjective = await ModelsObjective.create({
                title: 'Tareas Generales',
                description: 'Objetivo creado autom√°ticamente para tareas sin objetivo espec√≠fico',
                group_id: groupId,
                created_by: userId
              })
              console.log('   ‚úÖ Objetivo general creado con ID:', generalObjective.id)
              console.log('   üè¢ En el grupo:', generalObjective.group_id)
            } else {
              console.log('   ‚úÖ Usando objetivo existente:', generalObjective.id)
            }
            
            taskInfo.objective_id = generalObjective.id
          } else if (objectiveId) {
            // Si hay un objetivo activo en el contexto, usarlo
            taskInfo.objective_id = objectiveId
          }
          
          console.log('   Creando tarea con objective_id:', taskInfo.objective_id)
          const task = await ModelsTask.create(taskInfo)
          
          // Construir mensaje de confirmaci√≥n
          let assignmentInfo = ''
          if (task.assigned_to === 'all') {
            assignmentInfo = '\nüë• **Asignada a:** Todo el equipo'
          } else if (task.assigned_to) {
            assignmentInfo = `\nüë§ **Asignada a:** @${task.assigned_to}`
          } else {
            assignmentInfo = '\nüÜì **Tarea libre** - Cualquier miembro puede tomarla'
          }
          
          return {
            success: true,
            action: 'task_created',
            data: task,
            message: `‚úÖ **Tarea creada exitosamente:**\n\nüìã **${task.title}**\n${task.description ? `üìù ${task.description}\n` : ''}üéØ Prioridad: **${this.translatePriority(task.priority)}**${task.deadline ? `\nüìÖ Fecha l√≠mite: **${this.formatDate(task.deadline)}**` : ''}${assignmentInfo}\nüìÇ Objetivo: **${taskInfo.objective_id === task.objective_id ? 'Tareas Generales' : 'Asignado'}**`
          }
        }
        
        case 'createObjective': {
          console.log('   üìù Extrayendo info de objetivo...')
          const objectiveInfo = this.extractObjectiveInfo(message, userId, groupId)
          console.log('   üì¶ Info del objetivo a crear:', JSON.stringify(objectiveInfo, null, 2))
          
          const objective = await ModelsObjective.create(objectiveInfo)
          console.log('   ‚úÖ Objetivo creado:', objective.id)
          console.log('   üè¢ En grupo:', objective.group_id)
          
          return {
            success: true,
            action: 'objective_created',
            data: objective,
            message: `üéØ **Objetivo creado exitosamente:**\n\n**${objective.title}**\n${objective.description ? `\nüìù ${objective.description}\n` : ''}${objective.deadline ? `üìÖ Fecha l√≠mite: **${this.formatDate(objective.deadline)}**\n` : ''}\n‚ú® ¬°Ahora puedes empezar a crear tareas para este objetivo!`
          }
        }
        
        case 'createEvent':
        case 'scheduleReminder': {
          const eventInfo = this.extractEventInfo(message, userId, groupId)
          
          if (!eventInfo.event_date) {
            return {
              success: false,
              action: 'event_creation_failed',
              message: '‚ö†Ô∏è No pude detectar una fecha v√°lida. Por favor especifica cu√°ndo quieres el evento (ej: "ma√±ana a las 3pm", "el pr√≥ximo viernes", "el 15 de diciembre")'
            }
          }
          
          const event = await Event.create(eventInfo)
          
          return {
            success: true,
            action: 'event_created',
            data: event,
            message: `üìÖ **Evento agendado exitosamente:**\n\n**${event.title}**\n${event.description ? `üìù ${event.description}\n` : ''}üìÜ Fecha: **${this.formatDate(event.event_date)}**${event.event_time ? `\nüïê Hora: **${event.event_time}**` : ''}\nüîî Tipo: **${this.translateEventType(event.event_type)}**\n${event.reminder_enabled ? `‚è∞ Recordatorio activado (${event.reminder_minutes} min antes)` : ''}`
          }
        }
        
        case 'createIdea': {
          const ideaInfo = this.extractIdeaInfo(message, userId, groupId)
          const idea = await Idea.create(ideaInfo)
          
          return {
            success: true,
            action: 'idea_created',
            data: idea,
            message: `üí° **Idea publicada en el muro exitosamente:**\n\n**${idea.title}**\n${idea.description ? `üìù ${idea.description}\n` : ''}üìÇ Categor√≠a: **${this.translateCategory(idea.category)}**\n‚≠ê Prioridad: **${this.translatePriority(idea.priority)}**\nüë• Estado: **Propuesta** (pendiente de revisi√≥n)\n\n¬°Gracias por contribuir con tus ideas! üöÄ`
          }
        }
        
        case 'queryTasks': {
          return await this.queryTasksStatus(message, userId, groupId)
        }
        
        case 'queryGroupInfo': {
          return await this.queryGroupInformation(message, userId, groupId)
        }
        
        case 'listFreeTasks': {
          return await this.listAvailableTasks(message, userId, groupId)
        }
        
        case 'takeTask': {
          return await this.assignTaskToUser(message, userId, groupId)
        }
        
        default:
          return {
            success: false,
            action: 'unknown_action',
            message: 'No pude interpretar la acci√≥n solicitada.'
          }
      }
      
    } catch (error) {
      console.error('‚ùå Error en NLP Action Service:', error)
      return {
        success: false,
        action: 'error',
        message: `‚ùå Hubo un error al procesar tu solicitud: ${error.message}`,
        error: error.message
      }
    }
  }

  /**
   * Traduce prioridad a espa√±ol
   */
  translatePriority(priority) {
    const translations = {
      low: 'Baja',
      medium: 'Media',
      high: 'Alta',
      critical: 'Cr√≠tica'
    }
    return translations[priority] || priority
  }

  /**
   * Traduce categor√≠a de idea a espa√±ol
   */
  translateCategory(category) {
    const translations = {
      general: 'General',
      feature: 'Nueva Funci√≥n',
      improvement: 'Mejora',
      bug: 'Reporte de Bug',
      other: 'Otro'
    }
    return translations[category] || category
  }

  /**
   * Traduce tipo de evento a espa√±ol
   */
  translateEventType(eventType) {
    const translations = {
      meeting: 'Reuni√≥n',
      deadline: 'Fecha l√≠mite',
      milestone: 'Hito',
      reminder: 'Recordatorio',
      celebration: 'Celebraci√≥n'
    }
    return translations[eventType] || eventType
  }

  /**
   * Formatea fecha de manera amigable
   */
  formatDate(dateString) {
    if (!dateString) return 'No especificada'
    
    const date = new Date(dateString)
    const options = { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    }
    
    return date.toLocaleDateString('es-ES', options)
  }

  /**
   * üÜï Consultar estado de tareas
   */
  async queryTasksStatus(message, userId, groupId) {
    try {
      console.log('\nüìä Consultando estado de tareas...')
      
      // Detectar si pregunta por tareas de alguien espec√≠fico
      const userMatch = message.match(/tareas?\s+de\s+(?:@)?(\w+)/i)
      const targetUser = userMatch ? userMatch[1].toLowerCase() : null
      
      // Obtener objetivos del grupo
      const objectives = await ModelsObjective.getByGroupId(groupId)
      
      if (!objectives || objectives.length === 0) {
        return {
          success: true,
          action: 'tasks_query',
          message: 'üìã No hay objetivos en este grupo todav√≠a.'
        }
      }
      
      // Recopilar todas las tareas
      let allTasks = []
      for (const objective of objectives) {
        const tasks = await ModelsTask.getByObjectiveId(objective.id)
        allTasks = allTasks.concat(tasks.map(t => ({ ...t, objective_title: objective.title })))
      }
      
      if (allTasks.length === 0) {
        return {
          success: true,
          action: 'tasks_query',
          message: 'üìã No hay tareas creadas todav√≠a en este grupo.'
        }
      }
      
      // Filtrar por usuario si se especific√≥
      if (targetUser) {
        allTasks = allTasks.filter(t => 
          t.assigned_to && t.assigned_to.toLowerCase() === targetUser
        )
        
        if (allTasks.length === 0) {
          return {
            success: true,
            action: 'tasks_query',
            message: `üìã No hay tareas asignadas a **${targetUser}**.`
          }
        }
      }
      
      // Agrupar por estado
      const pending = allTasks.filter(t => t.status === 'pending')
      const inProgress = allTasks.filter(t => t.status === 'in_progress')
      const completed = allTasks.filter(t => t.status === 'completed')
      
      // Construir mensaje
      let responseMessage = `üìä **Estado de Tareas**${targetUser ? ` de **${targetUser}**` : ''}:\n\n`
      responseMessage += `üìà **Resumen:**\n`
      responseMessage += `- ‚úÖ Completadas: **${completed.length}**\n`
      responseMessage += `- üîÑ En progreso: **${inProgress.length}**\n`
      responseMessage += `- ‚è≥ Pendientes: **${pending.length}**\n`
      responseMessage += `- üìä Total: **${allTasks.length}**\n\n`
      
      // Mostrar tareas urgentes pendientes
      const urgentPending = pending.filter(t => t.priority === 'critical' || t.priority === 'high')
      if (urgentPending.length > 0) {
        responseMessage += `üö® **Tareas Urgentes Pendientes:**\n`
        urgentPending.slice(0, 5).forEach(task => {
          responseMessage += `- **${task.title}** (${this.translatePriority(task.priority)})\n`
          if (task.deadline) responseMessage += `  üìÖ Vence: ${this.formatDate(task.deadline)}\n`
        })
      }
      
      return {
        success: true,
        action: 'tasks_query',
        data: { pending, inProgress, completed, total: allTasks.length },
        message: responseMessage
      }
      
    } catch (error) {
      console.error('‚ùå Error consultando tareas:', error)
      return {
        success: false,
        action: 'tasks_query_error',
        message: `‚ùå Error al consultar las tareas: ${error.message}`
      }
    }
  }

  /**
   * üÜï Consultar informaci√≥n del grupo
   */
  async queryGroupInformation(message, userId, groupId) {
    try {
      console.log('\nüë• Consultando informaci√≥n del grupo...')
      
      const { ModelsGroup } = await import('../models/group.js')
      const { ModelsUser } = await import('../models/user.js')
      
      // Obtener informaci√≥n del grupo
      const group = await ModelsGroup.getById(groupId)
      
      if (!group) {
        return {
          success: false,
          action: 'group_query',
          message: '‚ùå No se pudo obtener informaci√≥n del grupo.'
        }
      }
      
      // Obtener miembros (esto depende de tu estructura de BD)
      // Aqu√≠ asumo que hay una funci√≥n para obtener miembros
      let members = []
      try {
        members = await ModelsUser.getByGroupId(groupId)
      } catch (error) {
        console.log('‚ö†Ô∏è No se pudieron obtener los miembros:', error.message)
      }
      
      // Obtener estad√≠sticas
      const objectives = await ModelsObjective.getByGroupId(groupId)
      let totalTasks = 0
      let completedTasks = 0
      
      for (const objective of objectives) {
        const tasks = await ModelsTask.getByObjectiveId(objective.id)
        totalTasks += tasks.length
        completedTasks += tasks.filter(t => t.status === 'completed').length
      }
      
      // Construir respuesta
      let responseMessage = `üë• **Informaci√≥n del Grupo: ${group.name}**\n\n`
      
      if (members.length > 0) {
        responseMessage += `üìä **Miembros:** ${members.length}\n`
        responseMessage += members.slice(0, 10).map(m => `- ${m.username || m.name || m.email}`).join('\n')
        if (members.length > 10) responseMessage += `\n...y ${members.length - 10} m√°s`
        responseMessage += '\n\n'
      }
      
      responseMessage += `üìà **Estad√≠sticas:**\n`
      responseMessage += `- üéØ Objetivos: **${objectives.length}**\n`
      responseMessage += `- üìã Tareas totales: **${totalTasks}**\n`
      responseMessage += `- ‚úÖ Tareas completadas: **${completedTasks}**\n`
      
      if (totalTasks > 0) {
        const completionRate = ((completedTasks / totalTasks) * 100).toFixed(1)
        responseMessage += `- üìä Tasa de completaci√≥n: **${completionRate}%**\n`
      }
      
      return {
        success: true,
        action: 'group_query',
        data: { group, members, objectives, totalTasks, completedTasks },
        message: responseMessage
      }
      
    } catch (error) {
      console.error('‚ùå Error consultando grupo:', error)
      return {
        success: false,
        action: 'group_query_error',
        message: `‚ùå Error al consultar informaci√≥n del grupo: ${error.message}`
      }
    }
  }

  /**
   * üÜï Listar tareas libres (sin asignar)
   */
  async listAvailableTasks(message, userId, groupId) {
    try {
      console.log('\nüìã Listando tareas libres...')
      
      // Obtener objetivos del grupo
      const objectives = await ModelsObjective.getByGroupId(groupId)
      
      if (!objectives || objectives.length === 0) {
        return {
          success: true,
          action: 'free_tasks_list',
          message: 'üìã No hay objetivos en este grupo todav√≠a.'
        }
      }
      
      // Recopilar tareas libres
      let freeTasks = []
      for (const objective of objectives) {
        const tasks = await ModelsTask.getByObjectiveId(objective.id)
        const free = tasks.filter(t => !t.assigned_to && t.status === 'pending')
        freeTasks = freeTasks.concat(free.map(t => ({ ...t, objective_title: objective.title })))
      }
      
      if (freeTasks.length === 0) {
        return {
          success: true,
          action: 'free_tasks_list',
          message: 'üéâ No hay tareas libres en este momento. ¬°Todas las tareas est√°n asignadas o completadas!'
        }
      }
      
      // Ordenar por prioridad
      const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 }
      freeTasks.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority])
      
      // Construir mensaje
      let responseMessage = `üÜì **Tareas Disponibles** (${freeTasks.length}):\n\n`
      
      freeTasks.slice(0, 10).forEach((task, index) => {
        responseMessage += `${index + 1}. **${task.title}**\n`
        responseMessage += `   üéØ Prioridad: ${this.translatePriority(task.priority)}\n`
        if (task.deadline) responseMessage += `   üìÖ Vence: ${this.formatDate(task.deadline)}\n`
        responseMessage += `   üìÇ Objetivo: ${task.objective_title}\n`
        responseMessage += `   üí¨ _Escribe "tomo la tarea" para asign√°rtela_\n\n`
      })
      
      if (freeTasks.length > 10) {
        responseMessage += `...y ${freeTasks.length - 10} tareas m√°s.\n\n`
      }
      
      responseMessage += `üí° **Tip:** Di "tomo la tarea [nombre]" para asignarte una tarea espec√≠fica.`
      
      return {
        success: true,
        action: 'free_tasks_list',
        data: freeTasks,
        message: responseMessage
      }
      
    } catch (error) {
      console.error('‚ùå Error listando tareas libres:', error)
      return {
        success: false,
        action: 'free_tasks_error',
        message: `‚ùå Error al listar tareas: ${error.message}`
      }
    }
  }

  /**
   * üÜï Asignar tarea al usuario (tomar tarea)
   */
  async assignTaskToUser(message, userId, groupId) {
    try {
      console.log('\nüë§ Usuario tomando tarea...')
      
      // Detectar qu√© tarea quiere tomar
      const taskNameMatch = message.match(/tarea\s+(.+?)(?:\s*$|\.)/i)
      const taskName = taskNameMatch ? taskNameMatch[1].trim() : null
      
      // Obtener objetivos del grupo
      const objectives = await ModelsObjective.getByGroupId(groupId)
      
      // Buscar tarea libre que coincida
      let targetTask = null
      for (const objective of objectives) {
        const tasks = await ModelsTask.getByObjectiveId(objective.id)
        const freeTasks = tasks.filter(t => !t.assigned_to && t.status === 'pending')
        
        if (taskName) {
          // Buscar tarea espec√≠fica por nombre
          targetTask = freeTasks.find(t => 
            t.title.toLowerCase().includes(taskName.toLowerCase())
          )
        } else {
          // Tomar la primera tarea libre con mayor prioridad
          const sorted = freeTasks.sort((a, b) => {
            const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 }
            return priorityOrder[a.priority] - priorityOrder[b.priority]
          })
          targetTask = sorted[0]
        }
        
        if (targetTask) break
      }
      
      if (!targetTask) {
        return {
          success: false,
          action: 'take_task',
          message: taskName 
            ? `‚ùå No encontr√© ninguna tarea libre llamada "${taskName}".`
            : '‚ùå No hay tareas libres disponibles en este momento.'
        }
      }
      
      // Asignar tarea al usuario
      const { ModelsUser } = await import('../models/user.js')
      const user = await ModelsUser.getById(userId)
      
      // Actualizar la tarea (necesitar√≠as un m√©todo update en el modelo)
      // Por ahora, lo hacemos directamente
      const { getConnection } = await import('../config/db.js')
      const connection = await getConnection()
      
      await connection.execute(
        'UPDATE tasks SET assigned_to = ? WHERE id = ?',
        [userId, targetTask.id]
      )
      
      connection.end()
      
      return {
        success: true,
        action: 'task_assigned',
        data: { task: targetTask, user },
        message: `‚úÖ **¬°Tarea asignada exitosamente!**\n\nüìã **${targetTask.title}**\nüë§ Asignada a: **${user.username || user.email}**\nüéØ Prioridad: **${this.translatePriority(targetTask.priority)}**${targetTask.deadline ? `\nüìÖ Fecha l√≠mite: **${this.formatDate(targetTask.deadline)}**` : ''}\n\nüí™ ¬°Mucho √©xito con esta tarea!`
      }
      
    } catch (error) {
      console.error('‚ùå Error asignando tarea:', error)
      return {
        success: false,
        action: 'take_task_error',
        message: `‚ùå Error al tomar la tarea: ${error.message}`
      }
    }
  }
}

// Exportar instancia singleton
const nlpActionService = new NLPActionService()
export default nlpActionService
